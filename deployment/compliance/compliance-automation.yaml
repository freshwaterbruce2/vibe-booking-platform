# Compliance Automation for SOC2 and PCI-DSS
apiVersion: v1
kind: Namespace
metadata:
  name: compliance-system
  labels:
    compliance: enabled
    environment: production
---
# Open Policy Agent (OPA) for policy enforcement
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policies
  namespace: compliance-system
data:
  # SOC2 Policies
  soc2-access-control.rego: |
    package soc2.access
    
    # Enforce least privilege access
    deny[msg] {
      input.request.kind.kind == "RoleBinding"
      input.request.object.roleRef.name == "cluster-admin"
      not input.request.userInfo.username in ["authorized-admin@company.com"]
      msg := "Cluster-admin role can only be assigned by authorized personnel"
    }
    
    # Enforce MFA for sensitive operations
    deny[msg] {
      sensitive_operation
      not input.request.userInfo.extra["auth-method"][_] == "mfa"
      msg := "Multi-factor authentication required for sensitive operations"
    }
    
    sensitive_operation {
      input.request.verb in ["create", "update", "patch", "delete"]
      input.request.resource.resource in ["secrets", "configmaps"]
    }
    
    # Audit logging requirements
    deny[msg] {
      input.request.kind.kind == "Pod"
      not input.request.object.metadata.annotations["audit.compliance/enabled"] == "true"
      msg := "All pods must have audit logging enabled"
    }
  
  # PCI-DSS Policies
  pci-encryption.rego: |
    package pci.encryption
    
    # Enforce encryption at rest
    deny[msg] {
      input.request.kind.kind == "PersistentVolumeClaim"
      not input.request.object.spec.storageClassName == "encrypted-gp3"
      msg := "PCI-DSS requires encryption at rest for all storage"
    }
    
    # Enforce TLS for all services
    deny[msg] {
      input.request.kind.kind == "Service"
      input.request.object.spec.ports[_].port == 80
      not input.request.object.metadata.annotations["service.beta.kubernetes.io/aws-load-balancer-ssl-cert"]
      msg := "PCI-DSS requires TLS encryption for all services"
    }
    
    # Enforce secure container images
    deny[msg] {
      input.request.kind.kind == "Pod"
      container := input.request.object.spec.containers[_]
      not starts_with(container.image, "approved-registry.company.com/")
      msg := sprintf("Container image %v must be from approved registry", [container.image])
    }
    
    # Network segmentation
    deny[msg] {
      input.request.kind.kind == "NetworkPolicy"
      not input.request.object.spec.policyTypes[_] == "Ingress"
      not input.request.object.spec.policyTypes[_] == "Egress"
      msg := "PCI-DSS requires explicit network policies for ingress and egress"
    }
  
  # Data retention policies
  data-retention.rego: |
    package compliance.retention
    
    # Enforce log retention
    deny[msg] {
      input.request.kind.kind == "ConfigMap"
      input.request.object.metadata.name == "fluent-bit-config"
      not contains(input.request.object.data["output-elasticsearch.conf"], "logstash_retention_days 90")
      msg := "Logs must be retained for at least 90 days for compliance"
    }
    
    # Enforce backup retention
    deny[msg] {
      input.request.kind.kind == "CronJob"
      contains(input.request.object.metadata.name, "backup")
      not input.request.object.spec.jobTemplate.spec.template.spec.containers[_].env[_].value >= "30"
      msg := "Backups must be retained for at least 30 days"
    }
---
# OPA Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa
  namespace: compliance-system
spec:
  replicas: 3
  selector:
    matchLabels:
      app: opa
  template:
    metadata:
      labels:
        app: opa
    spec:
      containers:
      - name: opa
        image: openpolicyagent/opa:0.55.0-envoy
        ports:
        - containerPort: 8181
        args:
          - "run"
          - "--server"
          - "--config-file=/config/config.yaml"
          - "/policies"
        volumeMounts:
        - name: opa-policies
          mountPath: /policies
        - name: opa-config
          mountPath: /config
        livenessProbe:
          httpGet:
            path: /health
            port: 8181
          initialDelaySeconds: 10
          periodSeconds: 5
        readinessProbe:
          httpGet:
            path: /health?bundle=true
            port: 8181
          initialDelaySeconds: 10
          periodSeconds: 5
      volumes:
      - name: opa-policies
        configMap:
          name: opa-policies
      - name: opa-config
        configMap:
          name: opa-config
---
# Falco for runtime security monitoring
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: falco
  namespace: compliance-system
spec:
  selector:
    matchLabels:
      app: falco
  template:
    metadata:
      labels:
        app: falco
    spec:
      serviceAccountName: falco
      hostNetwork: true
      hostPID: true
      containers:
      - name: falco
        image: falcosecurity/falco:0.35.1
        privileged: true
        env:
        - name: FALCO_GRPC_ENABLED
          value: "true"
        - name: FALCO_GRPC_BIND_ADDRESS
          value: "0.0.0.0:5060"
        volumeMounts:
        - mountPath: /host/var/run/docker.sock
          name: docker-socket
        - mountPath: /host/dev
          name: dev-fs
        - mountPath: /host/proc
          name: proc-fs
          readOnly: true
        - mountPath: /host/boot
          name: boot-fs
          readOnly: true
        - mountPath: /host/lib/modules
          name: lib-modules
          readOnly: true
        - mountPath: /host/usr
          name: usr-fs
          readOnly: true
        - mountPath: /etc/falco
          name: falco-config
      volumes:
      - name: docker-socket
        hostPath:
          path: /var/run/docker.sock
      - name: dev-fs
        hostPath:
          path: /dev
      - name: proc-fs
        hostPath:
          path: /proc
      - name: boot-fs
        hostPath:
          path: /boot
      - name: lib-modules
        hostPath:
          path: /lib/modules
      - name: usr-fs
        hostPath:
          path: /usr
      - name: falco-config
        configMap:
          name: falco-config
---
# Falco Rules for Compliance
apiVersion: v1
kind: ConfigMap
metadata:
  name: falco-config
  namespace: compliance-system
data:
  falco.yaml: |
    rules_file:
      - /etc/falco/falco_rules.yaml
      - /etc/falco/compliance_rules.yaml
    
    json_output: true
    json_include_output_property: true
    
    log_stderr: true
    log_syslog: false
    log_level: info
    
    outputs:
      - name: syslog
        enabled: false
      - name: file
        enabled: true
        filename: /var/log/falco/events.log
      - name: stdout
        enabled: true
      - name: webserver
        enabled: true
        url: http://falco-exporter:2801/
  
  compliance_rules.yaml: |
    # SOC2 Compliance Rules
    - rule: Unauthorized Process in Container
      desc: Detect unauthorized process execution in containers
      condition: >
        spawned_process and container and
        not proc.name in (allowed_processes)
      output: >
        Unauthorized process in container (user=%user.name command=%proc.cmdline container_id=%container.id image=%container.image.repository)
      priority: WARNING
      tags: [soc2, process]
    
    - rule: Sensitive File Access
      desc: Detect access to sensitive files
      condition: >
        open_read and 
        (fd.name startswith /etc/shadow or
         fd.name startswith /etc/passwd or
         fd.name contains credentials or
         fd.name contains private_key)
      output: >
        Sensitive file accessed (user=%user.name command=%proc.cmdline file=%fd.name container_id=%container.id)
      priority: ERROR
      tags: [soc2, filesystem]
    
    # PCI-DSS Compliance Rules
    - rule: Clear Text Credentials
      desc: Detect potential clear text credential usage
      condition: >
        spawned_process and
        (proc.args contains "password=" or
         proc.args contains "passwd=" or
         proc.args contains "pwd=" or
         proc.env contains "PASSWORD=")
      output: >
        Clear text credentials detected (user=%user.name command=%proc.cmdline container_id=%container.id)
      priority: CRITICAL
      tags: [pci, credentials]
    
    - rule: Unauthorized Network Connection
      desc: Detect unauthorized outbound connections
      condition: >
        outbound and 
        not (fd.rip in (allowed_ips) or
             fd.rip in (private_subnets))
      output: >
        Unauthorized network connection (user=%user.name command=%proc.cmdline connection=%fd.name container_id=%container.id)
      priority: ERROR
      tags: [pci, network]
    
    - rule: Database Direct Access
      desc: Detect direct database access bypassing application
      condition: >
        inbound and
        fd.sport in (5432, 3306, 27017) and
        not proc.name in (allowed_db_clients)
      output: >
        Direct database access detected (user=%user.name command=%proc.cmdline connection=%fd.name)
      priority: CRITICAL
      tags: [pci, database]
---
# Compliance Scanner CronJob
apiVersion: batch/v1
kind: CronJob
metadata:
  name: compliance-scanner
  namespace: compliance-system
spec:
  schedule: "0 */6 * * *"  # Every 6 hours
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: compliance-scanner
          containers:
          - name: scanner
            image: aquasec/trivy:latest
            command:
            - /bin/sh
            - -c
            - |
              # Scan all running images for vulnerabilities
              kubectl get pods --all-namespaces -o json | \
              jq -r '.items[].spec.containers[].image' | \
              sort -u | \
              while read image; do
                echo "Scanning $image"
                trivy image --severity HIGH,CRITICAL --format json $image > /tmp/scan-result.json
                
                # Send results to compliance dashboard
                curl -X POST http://compliance-dashboard:8080/api/scans \
                  -H "Content-Type: application/json" \
                  -d @/tmp/scan-result.json
              done
              
              # Run CIS Kubernetes Benchmark
              kubectl apply -f https://raw.githubusercontent.com/aquasecurity/kube-bench/main/job.yaml
              
              # Check compliance status
              curl http://compliance-dashboard:8080/api/compliance/check
          restartPolicy: OnFailure
---
# Network Policies for PCI-DSS Segmentation
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: payment-isolation
  namespace: hotel-booking-production
spec:
  podSelector:
    matchLabels:
      component: payment
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          component: api
    ports:
    - protocol: TCP
      port: 8443
  egress:
  - to:
    - podSelector:
        matchLabels:
          component: payment-gateway
    ports:
    - protocol: TCP
      port: 443
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
      podSelector:
        matchLabels:
          k8s-app: kube-dns
    ports:
    - protocol: UDP
      port: 53
---
# Audit Configuration
apiVersion: audit.k8s.io/v1
kind: Policy
metadata:
  name: compliance-audit-policy
rules:
  # Log all requests to secrets at Metadata level
  - level: Metadata
    resources:
    - group: ""
      resources: ["secrets"]
  
  # Log all requests to pods at RequestResponse level
  - level: RequestResponse
    resources:
    - group: ""
      resources: ["pods", "services", "deployments"]
    namespaces: ["hotel-booking-production", "hotel-booking-staging"]
  
  # Log all requests from payment service at RequestResponse level
  - level: RequestResponse
    users: ["system:serviceaccount:hotel-booking-production:payment-sa"]
  
  # Log authentication failures
  - level: Metadata
    omitStages:
    - RequestReceived
    nonResourceURLs:
    - "/api/v1/namespaces/*/pods/*/exec"
    - "/api/v1/namespaces/*/pods/*/attach"
    - "/api/v1/namespaces/*/pods/*/portforward"
---
# Compliance Dashboard Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: compliance-dashboard
  namespace: compliance-system
spec:
  replicas: 2
  selector:
    matchLabels:
      app: compliance-dashboard
  template:
    metadata:
      labels:
        app: compliance-dashboard
    spec:
      containers:
      - name: dashboard
        image: hotel-booking/compliance-dashboard:latest
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: compliance-db
              key: url
        - name: SLACK_WEBHOOK
          valueFrom:
            secretKeyRef:
              name: compliance-notifications
              key: slack-webhook
        - name: PAGERDUTY_TOKEN
          valueFrom:
            secretKeyRef:
              name: compliance-notifications
              key: pagerduty-token
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
---
# Compliance Metrics Service
apiVersion: v1
kind: Service
metadata:
  name: compliance-metrics
  namespace: compliance-system
  labels:
    app: compliance-dashboard
spec:
  ports:
  - port: 8080
    name: http
  selector:
    app: compliance-dashboard
---
# ServiceMonitor for Prometheus
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: compliance-metrics
  namespace: compliance-system
spec:
  selector:
    matchLabels:
      app: compliance-dashboard
  endpoints:
  - port: http
    interval: 30s
    path: /metrics